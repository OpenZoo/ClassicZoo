{
	ZXTMGR v0.2-pre

	Do not edit this file - edit the following files:
	- ZXTCONF.INC (configuration)
	- ZXTTYPES.INC (extension type enum)

	Copyright (c) 2021 Adrian Siekierka

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
	SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
	RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
	CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
	CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
}

{$I-}
{$V-}
unit ZxtMgr;

interface
	uses GameVars;
	type
{$I ZXTTYPES.INC}
		TExtensionId = record
			Owner: longint;
			Selector: word;
		end;
		TExtensionBlockHeader = record
			Flags: word;
			Id: TExtensionId;
			FieldType: byte;
			FieldLength: word;
		end;
		TExtensionBlock = record
			ExtType: TExtensionType;
			Header: TExtensionBlockHeader;
			Data: pointer;
		end;
		TExtensionHandlerAction = (
			ExtActionLoad,
			ExtActionUnload
		);
		TExtensionHandlerState = record
			Action: TExtensionHandlerAction;
		end;
		{ Return true if the extension was read successfully. }
		TExtensionHandlerFunc = function(var block: TExtensionBlock; var state: TExtensionHandlerState): boolean;
	const
		FZxtExtParsingMust = $0001;
		FZxtExtReadingMust = $0002;
		FZxtExtWritingMust = $0004;
		FZxtExtPlayingShould = $0008;
		FZxtExtPlayingMust = $0010;
		FZxtExtEditingShould = $0020;
		FZxtExtPreserveShould = $0040;
		FZxtExtBlockHeaderKnown = $007F;
	var
		ExtensionEnabled: array[ExtUnlockExtensions .. ExtTypeEnd] of boolean;
		ExtensionPlayShould: boolean;
		ExtensionEditShould: boolean;
		ExtensionWriteCan: boolean;
	{ Assumes that the engine MUST be capable of reading and playing this world. }
	{ As such, the only flags exposed above are ExtensionPlayShould, ExtensionEditShould }
	{ and ExtensionWriteCan. }
	function ExtensionAnyEnabled: boolean;
	function ExtensionEnabledById(eowner: longint; eselector: word): boolean;
	function ZxtLoadExtensions(var worldFile: file; filename: TString50): boolean;
	function ZxtUnloadExtensions: boolean;
	function ZxtWriteExtensions(var extFile: file): boolean;
	function ZxtShowFlagError(isEditing: boolean): boolean;
	procedure ZxtRegisterExtensionSimple(extType: TExtensionType; ownerId: longint; selectorId: word);
	procedure ZxtRegisterExtension(extType: TExtensionType; ownerId: longint; selectorId: word; handler: TExtensionHandlerFunc);

implementation
uses Dos, TxtWind;

const
{$I ZXTCONF.INC}
	MAX_EXTENSION_BLOCKS = 3072;
type
	TExtBlockArray = array[1 .. MAX_EXTENSION_BLOCKS] of TExtensionBlock;
	TExtensionHeader = record
		Magic: integer;
		BlockCount: longint;
	end;
	TExtensionHandler = record
		Id: TExtensionId;
		HandlerFunc: TExtensionHandlerFunc;
	end;
var
	ExtensionBlocks: ^TExtBlockArray;
	ExtensionBlockCount: word; { actually loaded extensions }
	ExtensionBlockSize: word; { array size }
	ExtensionHandlers: array[0 .. (Ord(ExtTypeEnd) - 1)] of TExtensionHandler;

{$F+}

function ZxtDefaultExtensionHandler(var block: TExtensionBlock; var state: TExtensionHandlerState): boolean;
begin
	ZxtDefaultExtensionHandler := true;
end;

function ExtensionAnyEnabled: boolean;
var
	extId: word;
begin
	for extId := 0 to (Ord(ExtTypeEnd) - 1) do begin
		if ExtensionEnabled[TExtensionType(extId)] then begin
			ExtensionAnyEnabled := true;
			exit;
		end;
	end;

	ExtensionAnyEnabled := false;
end;

function ExtensionEnabledById(eowner: longint; eselector: word): boolean;
var
	extId: word;
begin
	for extId := 0 to (Ord(ExtTypeEnd) - 1) do begin
		if ExtensionEnabled[TExtensionType(extId)] then begin
			with ExtensionHandlers[extId].Id do begin
				if (Owner = eowner) and (Selector = eselector) then begin
					ExtensionEnabledById := true;
					exit;
				end;
			end;
		end;
	end;

	ExtensionEnabledById := false;
end;

function ZxtUnloadExtensions: boolean;
var
	blockId: word;
	state: TExtensionHandlerState;
begin
	state.Action := ExtActionUnload;

	for blockId := 1 to ExtensionBlockSize do begin
		with ExtensionBlocks^[blockId] do begin
			if not ExtensionHandlers[Ord(ExtType)].HandlerFunc(ExtensionBlocks^[blockId], state) then begin
				ZxtUnloadExtensions := false;
				exit;
			end;

			if Header.FieldLength > 0 then begin
				FreeMem(Data, Header.FieldLength);
			end;

			ExtensionEnabled[ExtType] := false;
		end;
	end;

	FreeMem(ExtensionBlocks, SizeOf(TExtensionBlock) * ExtensionBlockSize);
	ExtensionBlockSize := 0;
	ZxtUnloadExtensions := true;
end;

function ZxtLoadExtensions(var worldFile: file; filename: TString50): boolean;
var
	hdr: TExtensionHeader;
	bhdr: TExtensionBlockHeader;
	state: TExtensionHandlerState;
	zaxFile: file;
	extFile: ^file;
	bi: longint;
	extId: word;
	extFound: boolean;
label OnExtFound;
label OnError;
begin
	ZxtLoadExtensions := true;
	ExtensionPlayShould := true;
	ExtensionEditShould := true;
	ExtensionWriteCan := true;

	{ Clear all enabled extensions. }
	FillChar(ExtensionEnabled, Ord(ExtTypeEnd), 0);

	{ World.BoardCount is currently set to the world file's magic. }
	if World.BoardCount = ZXT_HEADER_MAGIC then begin
		{ .ZXT file. }
		extFile := @worldFile;

		{ Read extension header. }
		hdr.Magic := ZXT_HEADER_MAGIC;
		BlockRead(worldFile, hdr.BlockCount, 4);
	end else begin
		Assign(zaxFile, filename + '.ZAX');
		Reset(zaxFile, 1);
		if IOResult = 0 then begin
			{ .ZAX file. }
			extFile := @zaxFile;

			{ Read extension header. }
			BlockRead(extFile^, hdr, SizeOf(hdr));
		end else begin
			{ No extensions found. }
			exit;
		end;	
	end;

	{ Validate header. }
	if (IOResult <> 0) or (hdr.Magic <> ZXT_HEADER_MAGIC) or (hdr.BlockCount < 0)
	or (hdr.BlockCount > MAX_EXTENSION_BLOCKS) then begin
		ZxtLoadExtensions := false;
		goto OnError;
	end;

	ExtensionBlockCount := 0;
	ExtensionBlockSize := hdr.BlockCount;
	GetMem(ExtensionBlocks, SizeOf(TExtensionBlock) * ExtensionBlockSize);

	state.Action := ExtActionLoad;

	for bi := 1 to hdr.BlockCount do begin
		{ Parse extension. }
		BlockRead(extFile^, bhdr, SizeOf(bhdr));
		if (IOResult <> 0)
			or ((bhdr.Flags and (not FZxtExtBlockHeaderKnown)) <> 0)
			or (bhdr.FieldLength > 65519)
		then begin
			ZxtLoadExtensions := false;
			goto OnError;
		end;

		{ Figure out if we recognize this extension. }
		for extId := 0 to (Ord(ExtTypeEnd) - 1) do begin
			with ExtensionHandlers[extId].Id do begin
				if (bhdr.Id.Owner = Owner) and (bhdr.Id.Selector = Selector) then begin
					extFound := true;	
					goto OnExtFound;
				end;
			end;
		end;

		extFound := false;

	OnExtFound:
		{ Preserve the extension. }
		if extFound or ((bhdr.Flags and FZxtExtPreserveShould) <> 0) then begin
			Inc(ExtensionBlockCount);
			with ExtensionBlocks^[ExtensionBlockCount] do begin
				ExtType := TExtensionType(extId);
				Header := bhdr;
				if Header.FieldLength > 0 then begin
					GetMem(Data, Header.FieldLength);
					BlockRead(extFile^, Data^, Header.FieldLength);
				end;

				{ Load the extension. }
				if extFound then begin
					ExtensionEnabled[TExtensionType(extId)] := true;

					if not ExtensionHandlers[Ord(ExtType)].HandlerFunc(ExtensionBlocks^[ExtensionBlockCount], state) then begin
						ZxtLoadExtensions := false;
						goto OnError;
					end;
				end;
			end;
		end;

		if not extFound then begin
			{ Un-set flags, if we don't recognize it. }
			if (bhdr.Flags and (FZxtExtParsingMust or FZxtExtReadingMust or FZxtExtPlayingMust)) <> 0 then begin
				ZxtLoadExtensions := false;
				goto OnError;
			end;
			if (bhdr.Flags and FZxtExtPlayingShould) <> 0 then
				ExtensionPlayShould := false;
			if (bhdr.Flags and FZxtExtEditingShould) <> 0 then
				ExtensionEditShould := false;
			if (bhdr.Flags and FZxtExtWritingMust) <> 0 then
				ExtensionWriteCan := false;
		end;
	end;
OnError:
	{ Finish. }
	if World.BoardCount = ZXT_HEADER_MAGIC then begin
		{ .ZXT file. }
		BlockRead(extFile^, World.BoardCount, 2);
	end else begin
		{ .ZAX file. }
		Close(zaxFile);
	end;
end;

function ZxtWriteExtensions(var extFile: file): boolean;
var
	hdr: TExtensionHeader;
	bhdr: TExtensionBlockHeader;
	i: word;
	lenpos, retpos: longint;
label OnError;
begin
	if not ExtensionWriteCan then begin
	OnError:
		ZxtWriteExtensions := false;
		exit;
	end;

	hdr.Magic := ZXT_HEADER_MAGIC;
	hdr.BlockCount := ExtensionBlockCount;
	BlockWrite(extFile, hdr, SizeOf(hdr));
	if IOResult <> 0 then goto OnError;

	for i := 1 to ExtensionBlockCount do begin
		with ExtensionBlocks^[ExtensionBlockCount] do begin
			BlockWrite(extFile, Header, SizeOf(Header));
			if (IOResult <> 0) then goto OnError;

			if Header.FieldLength > 0 then begin
				BlockWrite(extFile, Data^, Header.FieldLength);
				if (IOResult <> 0) then goto OnError;
			end;
		end;		
	end;

	ZxtWriteExtensions := true;
end;

function ZxtShowFlagError(isEditing: boolean): boolean;
var
	textWindow: TTextWindowState;
	isFatal: boolean;
begin
	isFatal := (isEditing) and (not ExtensionWriteCan);
	ZxtShowFlagError := isFatal;

	if isFatal then
		textWindow.Title := 'Error'
	else begin
		if (isEditing and ExtensionEditShould) or ((not isEditing) and ExtensionPlayShould) then
			exit;
		textWindow.Title := 'Warning';
	end;

	TextWindowInitState(textWindow);
	TextWindowAppend(textWindow, 'This world uses extensions which are');
	TextWindowAppend(textWindow, 'not supported by this version of the');
	TextWindowAppend(textWindow, 'game engine.');
	TextWindowAppend(textWindow, '');
	if isFatal then
		TextWindowAppend(textWindow, 'This action is unavailable.')
	else if isEditing then
		TextWindowAppend(textWindow, 'Editing may be negatively impacted.')
	else
		TextWindowAppend(textWindow, 'Playing may be negatively impacted.');

	TextWindowDrawOpen(textWindow);
	TextWindowSelect(textWindow, false, false);
	TextWindowDrawClose(textWindow);
	TextWindowFree(textWindow);
end;

procedure ZxtRegisterExtensionSimple(extType: TExtensionType; ownerId: longint; selectorId: word);
begin
	ZxtRegisterExtension(extType, ownerId, selectorId, ZxtDefaultExtensionHandler);
end;

procedure ZxtRegisterExtension(extType: TExtensionType; ownerId: longint; selectorId: word; handler: TExtensionHandlerFunc);
begin
	with ExtensionHandlers[Ord(extType)] do begin
		Id.Owner := ownerId;
		Id.Selector := selectorId;
		HandlerFunc := handler;
	end;
end;

begin
	FillChar(ExtensionHandlers, SizeOf(ExtensionHandlers), 0);
end.
